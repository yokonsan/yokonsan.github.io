<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yokonsan" />
	
	
	
	<title>Docker入门：核心组件 ｜ 乾之 三爻</title>
	
    
    
    <meta name="description" content="什么是Docker Docker是一个能够把开发的应用程序自动部署到容器的开源引擎，他设计的目的就是要加强程序员写代码的开发环境和应用部署的生产环境的一致性，降低开发环境的代码在生产环境无法正常执行的风" />
    

    
    
    <meta name="keywords" content="技术, 生活, 分享" />
    

	
    
    <link rel="shortcut icon" href="https://yokonsan.github.io/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.github.io/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.github.io/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.github.io/css/highlight.css" />

    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://yokonsan.github.io/">
                    <span>乾之 三爻</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">yokon&#39;s blog</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/yokonsan" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                <a href="https://yokonsan.github.io/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2019/1/docker-core-component/'>Docker入门：核心组件</a></h2>
                        <span class="date">2019.01.23</span>
                    </div>
                    <div class="post_content markdown"><h2 id="什么是docker">什么是Docker</h2>
<p>Docker是一个能够把开发的应用程序自动部署到容器的开源引擎，他设计的目的就是要加强程序员写代码的开发环境和应用部署的生产环境的一致性，降低开发环境的代码在生产环境无法正常执行的风险。推荐阅读<a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a">HERE</a></p>
<h2 id="安装docker">安装Docker</h2>
<p>Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统可以使用这套脚本安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ curl -fsSL get.docker.com -o get-docker.sh
</span></span><span class="line"><span class="cl">$ sudo sh get-docker.sh --mirror Aliyun
</span></span></code></pre></div><p>脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</p>
<h3 id="启动-docker-ce">启动 Docker CE</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo systemctl <span class="nb">enable</span> docker
</span></span><span class="line"><span class="cl">$ sudo systemctl start docker
</span></span></code></pre></div><p>安装完毕，可以执行 <code>docker info</code>来查看是否安装成功。</p>
<h2 id="a-nameyqffgka操作镜像image"><a name="yqffgk"></a>操作镜像(Image)</h2>
<p>Docker 镜像是由文件系统叠加而成。可以将镜像理解为一个可执行的文件包，其中包含了运行容器所需的程序、资源、环境变量以及配置文件。</p>
<h3 id="a-namekvcdxna查找镜像"><a name="kvcdxn"></a>查找镜像</h3>
<p>Docker 公司运营着一个公共的镜像仓库(Registry) <a href="https://hub.docker.com">Docker Hub</a>，可以让我们很方便的保存并分享自己制作的镜像。开发过程中，我们使用到的镜像大部分都是可以直接使用 <code>Docker Hub</code> 中已经存在的镜像，即使自己有新的需求，也只需要对已有的镜像进行相应的改动。</p>
<p>我们可以使用 <code>docker search</code> 命令来查找所有 <code>Docker Hub</code>上的公共可用镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker search ubuntu
</span></span></code></pre></div><p><img src="/image/post40/post40_1.jpg" alt="post40_1.jpg"></p>
<p>上图为命令返回结果截图，其中返回信息为：</p>
<ul>
<li>NAME：仓库名；</li>
<li>DESCRIPTION：该镜像描述；</li>
<li>STARS：用户评价，star 数；</li>
<li>OFFICIAL：是否官方开发者管理的镜像，OK 即为是；</li>
<li>AUTOMATED：自动构建，表示该镜像是由 Docker Hub 的自动构建流程创建的。</li>
</ul>
<h3 id="a-nameo0bppaa拉取镜像"><a name="o0bppa"></a>拉取镜像</h3>
<p>查找到镜像后，使用 <code>docker pull</code> 命令来拉取该仓库的镜像，以 <code>ubuntu</code> 镜像为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker pull ubuntu:16.04
</span></span><span class="line"><span class="cl">16.04: Pulling from library/ubuntu
</span></span><span class="line"><span class="cl">7b8b6451c85f: Pull <span class="nb">complete</span> 
</span></span><span class="line"><span class="cl">ab4d1096d9ba: Pull <span class="nb">complete</span> 
</span></span><span class="line"><span class="cl">e6797d1788ac: Pull <span class="nb">complete</span> 
</span></span><span class="line"><span class="cl">e25c5c290bde: Pull <span class="nb">complete</span> 
</span></span><span class="line"><span class="cl">Digest: sha256:e547ecaba7d078800c358082088e6cc710c3affd1b975601792ec701c80cdd39
</span></span><span class="line"><span class="cl">Status: Downloaded newer image <span class="k">for</span> ubuntu:16.04
</span></span></code></pre></div><p>该命令指定了 <code>ubuntu</code> 镜像且标签为 <code>16.04</code> ，如果不指定镜像标签，则默认为 <code>latest</code> 。实际上每个镜像都带有一个标签，所以一个仓库可以存储多个镜像。</p>
<p><strong>注意：</strong> 如果没有梯子，国内拉取 <code>Docker Hub</code> 的镜像可能比较慢，建议配置 Docker 官方提供的中国加速地址：<a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ vim /etc/docker/daemon.json
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;registry-mirrors&#34;</span>: <span class="o">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;https://registry.docker-cn.com&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>将上面的 json 写入文件后，重启服务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ systemctl daemon-reload
</span></span><span class="line"><span class="cl">$ systemctl restart docker
</span></span></code></pre></div><p>查看配置是否生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker info
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Registry Mirrors:
</span></span><span class="line"><span class="cl"> https://registry.docker-cn.com/
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><h3 id="列出镜像">列出镜像</h3>
<p>本地镜像都保存在 Docker 宿主机的 <code>/var/lib/docker</code> 目录下，由 Docker 管理并且给我们提供必需的控制命令接口。如果想要查看当前守护进程(docker daemon)中存放和管理的镜像，可以使用 <code>docker images</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class="line"><span class="cl">yublog_db               latest              90ffef425f8a        <span class="m">2</span> weeks ago         373MB
</span></span><span class="line"><span class="cl">yublog_web              latest              5e102ae5a68d        <span class="m">2</span> weeks ago         978MB
</span></span><span class="line"><span class="cl">ubuntu                  16.04               a51debf7e1eb        <span class="m">6</span> weeks ago         116MB
</span></span><span class="line"><span class="cl">jupyter/base-notebook   latest              65eb0b6c51aa        <span class="m">2</span> months ago        814MB
</span></span><span class="line"><span class="cl">redis                   latest              0a153379a539        <span class="m">3</span> months ago        83.4MB
</span></span><span class="line"><span class="cl">alpine                  3.4                 174b26fe09c7        <span class="m">3</span> months ago        4.82MB
</span></span><span class="line"><span class="cl">python                  <span class="m">3</span>                   a9d071760c82        <span class="m">3</span> months ago        923MB
</span></span><span class="line"><span class="cl">nginx                   1.13.12             ae513a47849c        <span class="m">8</span> months ago        109MB
</span></span></code></pre></div><p>其中，我们可以得到一个镜像列表，其中包含了镜像仓库名，镜像标签，镜像ID，创建时间以及占用空间。</p>
<h3 id="删除镜像">删除镜像</h3>
<p>对于不再需要的镜像，可以使用 <code>docker rmi</code> 命令来删除指定镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rmi a51deb
</span></span><span class="line"><span class="cl">Untagged: ubuntu:16.04
</span></span><span class="line"><span class="cl">Untagged: ubuntu@sha256:e547ecaba7d078800c358082088e6cc710c3affd1b975601792ec701c80cdd39
</span></span><span class="line"><span class="cl">Deleted: sha256:a51debf7e1eb2018400cef1e4b01f2e9f591f6c739de7b5d6c142f954f3715a7
</span></span><span class="line"><span class="cl">Deleted: sha256:ad38d0b8ff5e07d6875cb39931e2c79fb90cf142584ea813437b013d3639678f
</span></span><span class="line"><span class="cl">Deleted: sha256:8ae3e0d35735ff77e9ef2a15816747b01316225829ece78dbc41bc50eddb7dfe
</span></span><span class="line"><span class="cl">Deleted: sha256:a6a57518ff0cc0e30c0e5c964abc052038413f57cd570bd89ab4e4493741a5b3
</span></span><span class="line"><span class="cl">Deleted: sha256:41c002c8a6fd36397892dc6dc36813aaa1be3298be4de93e4fe1f40b9c358d99
</span></span></code></pre></div><p>该命令后接镜像名或者镜像ID，需要注意的是如果该镜像创建了容器，则镜像不会被删除。
删除多个镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rmi 90ffef425f8a 5e102ae5a68d
</span></span></code></pre></div><p>删除所有镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rmi <span class="sb">`</span>docker images -a -q<span class="sb">`</span>
</span></span></code></pre></div><p>其中，<code>-a</code> 指令会列出一些仓库名和标签为 <code>&lt;none&gt;</code> 的镜像，这类镜像是虚悬镜像(dangling image)，这类镜像已经没有任何价值，可以随意删除。<code>-q</code> 指令表示只列出镜像的 ID。</p>
<h3 id="构建镜像">构建镜像</h3>
<p>运行一个容器的时候，我们需要使用 <code>docker run</code> 命令，然后指定使用哪个镜像作为容器运行的基础。虽然大部分镜像都可以在 <code>Docker Hub</code> 上找到，但是当没有找到满足我们需求的镜像时，我们就需要自己构建。Docker 可以让我们在一个启动的容器中(如 ubuntu)进行更改，然后使用 <code>docker commit</code> 命令提交更新。但是基本上在所有的情况下，不建议大家这么做，定制镜像应该使用 <code>Dockerfile</code> 来完成，然后使用 <code>dcoker build</code> 命令来构建。</p>
<p>Dockerfile 是 Docker 的镜像构建定义文件，其中包含构建镜像过程中需要执行的命令和其他操作。<code>Dockerfile</code> 相对于 <code>docker commit</code> 来说更具备复用性，构建过程也更加透明。</p>
<h4 id="手动构建镜像">手动构建镜像</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -it --name myweb ubuntu:16.04
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# apt-get -y update <span class="o">&amp;&amp;</span> apt-get -y install nginx
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# <span class="nb">echo</span> <span class="s1">&#39;daemon off;&#39;</span> &gt;&gt;/etc/nginx/nginx.conf
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# <span class="nb">exit</span>
</span></span></code></pre></div><p>我们使用 <code>docker run</code> 命令启动一个名为 <code>myweb</code> 的容器，基于名为 <code>ubuntu:16.04</code> 的镜像，如果 docker 没有在本地发现该镜像，则会从 <code>Docker Hub</code> 上拉取。<code>-i</code> 参数是保证容器开启了 <code>STDIN</code> ，<code>-t</code> 参数使容器分配一个伪tty终端。进入容器后，我们安装 <code>nginx</code> ，并且在 <code>nginx</code> 的配置文件中添加一行 <code>daemon off;</code> 保持 <code>nginx</code> 在前台一直运行，不会在退出容器后被杀死。接着使用 <code>docker commit</code> 名令提交对容器的修改，指定容器名称或ID，且指定一个目标镜像仓库和镜像名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker commit -m <span class="s2">&#34;first attempt&#34;</span> myweb kyu/myweb:1.0
</span></span><span class="line"><span class="cl">$ docker run -d -p 80:80 --name webcontainer kyu/myweb:1.0 /bin/bash -c <span class="s2">&#34;service nginx start&#34;</span>
</span></span><span class="line"><span class="cl">$ curl -I http://localhost:80
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">200</span> OK
</span></span></code></pre></div><p>提交镜像后，可以使用 <code>docker images</code> 命令查看到构建的镜像，<code>docker inspect</code> 命令接镜像名称或ID可以查看镜像的详细信息。<code>docker run</code> 以该镜像为基础启动了一个名为 <code>webcontainer</code> 的容器，并且在容器启动时启动 <code>nginx</code> 服务器。由于Docker 容器默认是在前台执行，所有需要加 <code>-d</code> 参数让容器在后台执行，<code>-p</code> 参数控制 Docker 运行时，将容器的80端口映射到宿主机80端口。</p>
<h4 id="dockerfile定制镜像">Dockerfile定制镜像</h4>
<p>我们需要创建一个目录，并且在该目录创建 <code>Dockerfile</code> 文件。该目录即为我们的镜像构建上下文环境。Dokcer 会在构建镜像时将上下文和该上下文中的文件和目录上传到 Docker 守护进程。这样守护进程就可以直接访问到我们想在镜像中放置的任何数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Dockerfile</span>
</span></span><span class="line"><span class="cl">FROM ubuntu:16.04
</span></span><span class="line"><span class="cl">MAINTAINER kyu yukun@eager.live
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> apt-get -y update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get -y install nginx <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;daemon off;&#39;</span> &gt;&gt;/etc/nginx/nginx.conf
</span></span><span class="line"><span class="cl">EXPOSE <span class="m">80</span>
</span></span><span class="line"><span class="cl">CMD <span class="o">[</span><span class="s2">&#34;service&#34;</span>, <span class="s2">&#34;nginx&#34;</span>, <span class="s2">&#34;start&#34;</span><span class="o">]</span>
</span></span></code></pre></div><p>上面的 <code>Dockerfile</code> 中其实只是写入一条条指令，这些指令会被顺序执行，并且一条指令就做了一次 <code>commit</code> 提交，每一次 <code>commit</code> 实际上就是在上一层镜像上再提交一层，构建一个新的镜像。所以合理安排其中的指令，尽量不要让镜像显得很多层很臃肿。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker build -t kyu/myweb:1.1 .
</span></span><span class="line"><span class="cl">$ docker run -d -p 80:80 --name webcontainer2 kyu/myweb:1.1
</span></span><span class="line"><span class="cl">$ curl -I http://localhost:80
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">200</span> OK
</span></span></code></pre></div><p><code>docker build</code> 命令用来构建镜像，Dockerfile 中的指令会被顺序执行，<code>-t</code> 参数用来指定镜像仓库和名称，建议大家为构建的镜像设置优雅的名称，以方便我们后续的管理。后面的 <code>.</code> 指定了当前目录的 Dockerfile。</p>
<h5 id="dockerfile指令">Dockerfile指令</h5>
<ul>
<li>FROM：<code>Dockerfile</code>  文件第一条指令必须是 <code>FROM</code> ，该指令指定一个基础镜像，后面的指令都是基于该镜像进行；</li>
<li>MAINTAINER：该指令主要是保存镜像构建者的信息；</li>
<li>RUN：该指令用于在构建镜像中执行指定的命令，多条 <code>RUN</code> 指令，建议串联做一条指令；</li>
<li>EXPOSE：该指令表示容器内的应用使用了容器的那个端口；</li>
<li>CMD：该指令指定容器__启动时__，需要执行的命令，在 <code>dokcer run</code> 启动容器时可以被覆盖；</li>
<li>ENTRYPOINT：该指令和 <code>CMD</code> 指令类似，不过该指令在容器启动时，不会被 <code>docker run</code> 命令覆盖且该命令的参数会作为 <code>ENTRYPOINT</code> 指令的参数，如果同时也定义了 <code>CMD</code> 指令，则 <code>CMD</code> 也会被当中参数传给 <code>ENTRYPOINT</code> 的参数；</li>
<li>ADD：该指令将上下文环境下的文件或目录复制到镜像内，不能对构建目录外的文件进行 <code>ADD</code> 操作，要赋值的源文件可以也是一个url地址。如果复制的是一个压缩文件，该指令为自动解压缩到镜像路径。示例：<code>ADD index.html /usr/share/nginx/html/index.html</code></li>
<li>COPY：该指令和 <code>ADD</code> 类似，但是它不会做提取和解压的工作；</li>
<li>VOLUME：该指令会在基于该镜像创建的容器中建立挂载点，用于保存一些必要的数据，这些数据不会被提交到镜像中，且可以在多个容器间共享。该指令只能指定容器中的挂载点(可以指定多个)，无法指定宿主机上对应的目录。示例：<code>VOLUME /data</code></li>
<li>WORKDIR：该指令指定工作目录，后面构建的每一层镜像也就是每一条指令，都是在该指令指定的目录下工作，如果目录不存在，该指令会自动建立。示例：<code>WORKDIR /work</code></li>
<li>ENV：该指令用于设置环境变量，后面顺序执行的指令可以直接使用该指令定义的变量，运行的容器中的应用也可以直接使用。示例：<code>ENV CONFIG=test</code></li>
</ul>
<h2 id="使用容器container">使用容器(Container)</h2>
<p>容器是基于一个 Docker 镜像创建的，它还包含一个程序执行环境和一系列指令集合。镜像是 Docker 生命周期中构建打包阶段，而容器则是启动执行阶段。</p>
<h3 id="启动容器">启动容器</h3>
<p>使用 <code>docker run</code> 命令可以启动一个容器，在上面构建镜像的时候已经提到了，不再举例。</p>
<h3 id="列出容器">列出容器</h3>
<p><code>docker ps</code> 可以列出运行中的容器，增加 <code>-a</code> 参数可以列出所有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker ps -a
</span></span><span class="line"><span class="cl">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS                      PORTS                    NAMES
</span></span><span class="line"><span class="cl">b9e4ce3b55ee        kyu/myweb:1.1           <span class="s2">&#34;service nginx start&#34;</span>    <span class="m">2</span> hours ago         Up <span class="m">2</span> hours                  0.0.0.0:80-&gt;80/tcp       webcontainer2
</span></span><span class="line"><span class="cl">ad101983fa61        ubuntu:16.04            <span class="s2">&#34;/bin/bash&#34;</span>              <span class="m">25</span> hours ago        Exited <span class="o">(</span>130<span class="o">)</span> <span class="m">25</span> hours ago                            myweb
</span></span></code></pre></div><p>我们可以看到容器的ID，基于的镜像名称，启动时容器最后执行的命令，创建时间，运行状态，端口映射情况，以及容器名称。</p>
<h3 id="停止容器">停止容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker stop b9e4ce3b55ee
</span></span></code></pre></div><h3 id="启动已停止的容器">启动已停止的容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker start b9e4ce3b55ee
</span></span></code></pre></div><h3 id="进入运行中的容器">进入运行中的容器</h3>
<p>大部分情况，我们的容器时在后台运行的，而如果我们想再次进入容器，可以使用 <code>docker attach</code> 和 <code>docker exec</code> 命令。以上面运行的 <code>webcontainer2</code> 容器为例：</p>
<p><strong>docker attach</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker attach webcontainer2
</span></span></code></pre></div><p>因为，该容器内部在前台运行着 <code>Nginx</code> ，可以看到，我们虽然进入了容器内，却没有进入交互式会话的 <code>shell</code> 。此外，使用 <code>docker attach</code> 进入容器内部，如果使用 <code>exit</code> 退出容器的话，该容器也会跟着停止。</p>
<p><strong>docker exec</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker <span class="nb">exec</span> -it webcontainer2 /bin/bash
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# <span class="nb">exit</span>
</span></span></code></pre></div><p>该命令后面可以接 <code>-i</code> <code>-t</code> 选项，让我们可以进入交互式会话，而该命令进入容器，并使用 <code>exit</code> 退出，并不会导致容器停止。由于该命令后面可以跟指定的选项，我们可以利用它来在运行中的容器内，执行后台任务( <code>$ docker exec -d webcontainer2 touch /etc/new_file</code> )。</p>
<h3 id="查看容器日志">查看容器日志</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker logs webcontainer2
</span></span><span class="line"><span class="cl">* Starting nginx nginx
</span></span></code></pre></div><p>查看最后 10 行日志输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker logs --tail <span class="m">10</span> webcontainer2
</span></span></code></pre></div><h3 id="查看容器内进程">查看容器内进程</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker top webcontainer2
</span></span></code></pre></div><h3 id="查看容器详细信息">查看容器详细信息</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker inspect webcontainer2
</span></span></code></pre></div><h3 id="删除容器">删除容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rm webcontainer2
</span></span></code></pre></div><p>删除所有容器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker rm <span class="sb">`</span>docker ps -a -q<span class="sb">`</span>
</span></span></code></pre></div><h2 id="网络network">网络(Network)</h2>
<p>Docker 推崇一个容器运行一个应用进程，而大部分情况下，一个服务不可能只包含一个应用进程。在 Docker 中，容器之间的连接且进行数据交换，是通过网络进行的，即 <code>Docker Networking</code> 。我们可以通过 Docker 封装的命令，很方便的为容器制定相应的通信方案。</p>
<h3 id="创建网络">创建网络</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network create app
</span></span><span class="line"><span class="cl">e662833b17caa8701cc0e3f4a37a91cc14fd609712a52a1576f24993f9fe8288
</span></span></code></pre></div><p><code>docker network</code> 命令创建一个桥接网络，并且命名为 app，该命令给我们返回了新建网络的ID。</p>
<h3 id="列出网络">列出网络</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network ls
</span></span><span class="line"><span class="cl">NETWORK ID          NAME                DRIVER              SCOPE
</span></span><span class="line"><span class="cl">e662833b17ca        app                 bridge              <span class="nb">local</span>
</span></span><span class="line"><span class="cl">ca3663583680        bridge              bridge              <span class="nb">local</span>
</span></span><span class="line"><span class="cl">22d6c1b30299        host                host                <span class="nb">local</span>
</span></span><span class="line"><span class="cl">c81ee8057a47        none                null                <span class="nb">local</span>
</span></span></code></pre></div><p>Docker 默认创建的网络类型是 <code>bridge</code> ，在 <code>docker network create</code> 命令后添加 <code>-d</code> 选项可以自己选择网络类型为 <code>overlay</code> 。<code>overlay</code> 网络允许跨多台宿主机进行容器间通信。</p>
<h3 id="连接容器">连接容器</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --net app --name cache redis:latest
</span></span></code></pre></div><p>连接网络只要在 <code>--net</code> 选项后面添加需要连接的网络名称。</p>
<h3 id="查看网络详情">查看网络详情</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network inspect app
</span></span><span class="line"><span class="cl"><span class="o">[</span>
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Containers&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="s2">&#34;cdda3301a31f57604ceac29bf4cc0d8cf02e21e888ac9a28d6aa181482b262a6&#34;</span>: <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;cache&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;10920e91a17f85fce62b510a63f7cbd4d7a7bfa66017d5dc93f18a9eaffd5d89&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:ac:12:00:02&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;IPv4Address&#34;</span>: <span class="s2">&#34;172.18.0.2/16&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;IPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>,
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl"><span class="o">]</span>
</span></span></code></pre></div><p>可以看到该网络中多了一个连接的容器，以及他的 MAC 和 IP 地址。</p>
<h3 id="容器间通信">容器间通信</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run --net app --name <span class="nb">test</span> -it ubuntu:16.04 /bin/bash
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# apt-get -y update <span class="o">&amp;&amp;</span> apt-get -y install redis-tools
</span></span></code></pre></div><p>要想连接到上面创建的 <code>redis</code> 容器，甚至不需要指定 <code>redis</code> 容器的 IP 地址，只要指定需要连接 <code>redis</code> 容器的容器名称。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">root@4378d6da340c:/# redis-cli -h cache
</span></span><span class="line"><span class="cl">cache:6379&gt;
</span></span></code></pre></div><h3 id="已有容器连接网络">已有容器连接网络</h3>
<p><code>docker network connect</code> 命令可以使正在运行的容器连接到已有的网络中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network connect app webcontainer2
</span></span><span class="line"><span class="cl">$ docker network inspect app
</span></span></code></pre></div><h3 id="删除网络">删除网络</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker network rm app
</span></span></code></pre></div><h2 id="数据交互">数据交互</h2>
<p>在 Docker 中，实现容器内外或者容器之间的数据交互，需要使用到卷。卷是一个被选定的目录，可以绕过 Docker 的分层的联合文件系统(Union File System)，提供数据共享的功能。</p>
<h3 id="bind-mount">Bind Mount</h3>
<p>挂载宿主机的目录和文件到容器内，只需指定宿主机的路径和容器内的路径，就可以形成挂载映射关系，对目录或文件的修改会直接生效，并且互相可见。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir mydocker <span class="o">&amp;&amp;</span> <span class="nb">cd</span> mydocker
</span></span><span class="line"><span class="cl">$ touch hello.txt
</span></span><span class="line"><span class="cl">$ docker run --name test2 -it -v <span class="nv">$PWD</span>/hello.txt:/home/hello.txt ubuntu:16.04 /bin/bash
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# ls /home/
</span></span><span class="line"><span class="cl">hello.txt
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# <span class="nb">echo</span> <span class="s1">&#39;hello world&#39;</span> &gt; /home/hello.txt
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# cat /home/hello.txt
</span></span><span class="line"><span class="cl">hello world!!!
</span></span><span class="line"><span class="cl">root@4378d6da340c:/# <span class="nb">exit</span>
</span></span><span class="line"><span class="cl">$ cat hello.txt
</span></span><span class="line"><span class="cl">hello world!!!
</span></span></code></pre></div><p>使用 <code>-v</code> 或 <code>--volume</code> 选项，并且指定宿主机路径和容器内路径，格式：<code>-v &lt;host-path&gt;:&lt;container-path&gt;</code> ，如果容器内没有该路径，Docker 会自己创建。需要注意的是，这里指定的路径必须是绝对路径，这是为了避免定义数据卷名称的时候，出现混淆。在容器路径文件或目录后接 <code>:ro</code> 或者 <code>:rw</code> 可以指定容器内目录的读写状态：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir hello
</span></span><span class="line"><span class="cl">$ docker run --name test3 -it -v <span class="nv">$PWD</span>/hello:/home/hello:ro ubuntu:16.04 /bin/bash
</span></span></code></pre></div><p>很多时候 <code>Bind Mount</code> 挂载方式，是非常方便的。比如在构建镜像时，不想把应用或者代码构建到镜像中，把宿主机的程序挂载到容器内是很方便的方式。对于程序代码改动频繁，又不想在开发中频繁重构镜像，很适合使用这种挂载方式。在指定一些如 nginx、tomcat 软件的配置文件时，把文件挂载到容器内，也是很好的选择。</p>
<h3 id="volume">Volume</h3>
<p>数据卷也是从宿主机中挂载目录到 Docker 容器内，不过挂载的目录有 Docker 进行管理，定义数据卷时只需指定容器内的目录，并且数据卷默认会一直存在，即使引用的容器被删除。这种挂载方式适用于 Docker 写入本地的场景，比如我们想把数据库容器的数据写入到宿主机管理，并且可以让多个容器共享。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name db -it -v /var/lib/mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>password mysql:5.7
</span></span></code></pre></div><p>定义数据卷，仍然可以使用 <code>-v</code> 选项，不过我们只需要指定容器内的路径。为了方便我们记住数据卷，还可以指定数据卷的名称，格式：<code>-v &lt;name&gt;:&lt;container-path&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -d --name db -it -v dbdata:/var/lib/mysql -e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>password mysql:5.7
</span></span><span class="line"><span class="cl">$ docker inspect db
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;Mounts&#34;</span>: <span class="o">[</span>
</span></span><span class="line"><span class="cl">            <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Type&#34;</span>: <span class="s2">&#34;volume&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;dbdata&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Source&#34;</span>: <span class="s2">&#34;/var/lib/docker/volumes/7c2f70b0ed00045af78106f5e4d91f32d2064442b91e435b9e03ffe9c0f4df22/_data&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Destination&#34;</span>: <span class="s2">&#34;/var/lib/mysql&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;local&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Mode&#34;</span>: <span class="s2">&#34;&#34;</span>,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;RW&#34;</span>: true,
</span></span><span class="line"><span class="cl">                <span class="s2">&#34;Propagation&#34;</span>: <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">]</span>,
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><p>查看容器的详情，可以看到容器中挂载的数据卷信息。其中 <code>Name</code> 是数据卷的名称，如果不指定，默认是数据卷的ID。<code>Source</code> 信息是 Docker 为我们分配用于挂载的宿主机目录。</p>
<h4 id="创建数据卷">创建数据卷</h4>
<p>除了在启动容器时指定数据卷外，还可以使用 <code>docker volume</code> 命令来创建和管理数据卷。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker volume create mysqldb
</span></span><span class="line"><span class="cl">$ docker volume ls
</span></span><span class="line"><span class="cl">DRIVER              VOLUME NAME
</span></span><span class="line"><span class="cl"><span class="nb">local</span>                mysqldb
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><p>这样，在启动容器时，直接指定该数据卷即可，多个容器共享数据卷，只要指定数据卷名称或ID。</p>
<h4 id="删除数据卷">删除数据卷</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker volume rm mysqldb
</span></span></code></pre></div><p>如果有容器引用该数据卷，并且容器未被删除，则无法删除数据卷。数据卷在关联的容器被删除时不会一起被清除，所以在删除容器时加上 <code>-v</code> 选项可以一起删除关联的数据卷，当然需要保证该数据卷没有被其他容器所关联。</p>
<p>删除所以未被容器引用的数据卷：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker volume prune -f
</span></span></code></pre></div><h3 id="备份和迁移数据卷">备份和迁移数据卷</h3>
<p>如果想要备份或者迁移数据卷，可以使用 <code>docker inspect</code> 命令找到数据卷在宿主机上的位置，然后很轻松的实现备份或者迁移。</p>
<p>但是 Docker 为我们提供了更优雅的方法，我们可以利用数据卷容器共享的优势，指定一个 <code>ubuntu</code> 基础镜像，利用 <code>--volumes-from</code> 选项，挂载目标容器所有的卷，作为一个新的容器，然后执行 <code>tar cvf</code> 命令打包需要备份的目录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mkdir backup
</span></span><span class="line"><span class="cl">$ docker --rm --volumes-from db -v <span class="nv">$PWD</span>/backup:/backup ubuntu tar cvf /backup/backup.tar /var/lib/mysql 
</span></span></code></pre></div><p>命令解释：</p>
<ol>
<li>启动以一个 <code>ubuntu</code> 作基础镜像的容器；</li>
<li><code>--rm</code> 选项指定该容器进程运行结束后，自动删除容器；</li>
<li><code>--volumes-from</code> 选项指定了该容器挂载了目标容器 db 的所有卷；</li>
<li><code>-v</code> 选项将宿主机的 <code>$PWD/backup</code> 目录挂载为 <code>/backup</code> ；</li>
<li>将数据卷 <code>/var/lib/mysql</code> 的内容打包为 <code>backup.tar</code></li>
</ol>
<h2 id="参考">参考</h2>
<p><a href="https://docs.docker.com/">Docker官方文档</a></p>
<p><a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a">可能是把Docker的概念讲的最清楚的一篇文章</a></p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://yokonsan.github.io/tags/docker/">Docker</a>
                                    
                                    <a href="https://yokonsan.github.io/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>博观约取，厚积薄发</span>
    </div>
</footer>
    <script src="https://yokonsan.github.io/js/jquery-3.5.1.min.js"></script>
<link href="https://yokonsan.github.io/css/fancybox.min.css" rel="stylesheet">
<script src="https://yokonsan.github.io/js/fancybox.min.js"></script>
<script src="https://yokonsan.github.io/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



</body>

</html>