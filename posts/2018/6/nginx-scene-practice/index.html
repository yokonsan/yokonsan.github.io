<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yokonsan" />
	
	
	
	<title>Nginx场景实践 ｜ 乾之 三爻</title>
	
    
    
    <meta name="description" content="Nginx(读作：恩静 X)是一个高性能的HTTP和反向代理服务器，一个邮件代理以及通用的TCP/ UDP代理服务器。本篇文章是我最近使用Nginx的记录。你发现本站已经是全站https了，而本站的图片是" />
    

    
    
    <meta name="keywords" content="技术, 生活, 分享" />
    

	
    
    <link rel="shortcut icon" href="https://yokonsan.com/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.com/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.com/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://yokonsan.com/css/highlight.css" />

    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/posts/">Archive</a>
            </li>
            
            <li>
                <a href="/tags/">Tags</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://yokonsan.com/">
                    <span>乾之 三爻</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">yokon&#39;s blog</p>
            <div class="my_socials">
                
                
                <a href="https://github.com/yokonsan" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                <a href="https://yokonsan.com/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2018/6/nginx-scene-practice/'>Nginx场景实践</a></h2>
                        <span class="date">2018.06.30</span>
                    </div>
                    <div class="post_content markdown"><p><code>Nginx</code>(读作：恩静 X)是一个高性能的<code>HTTP</code>和反向代理服务器，一个邮件代理以及通用的<code>TCP/ UDP</code>代理服务器。本篇文章是我最近使用<code>Nginx</code>的记录。你发现本站已经是全站<code>https</code>了，而本站的图片是放在七牛云的。之所以可以使用<code>https://www.yukun.com/qiniu/xxx</code>访问到存放在七牛的图片，是因为使用了<code>nginx</code>的反向代理。</p>
<h2 id="安装">安装</h2>
<p>我们使用<code>Docker</code>启动一个<code>ubuntu</code>容器来演示安装过程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ sudo docker run -t -i -p 80：80 ubuntu:16.04 /bin/bash
</span></span><span class="line"><span class="cl">root@bbf4a330635d:/# cd root
</span></span><span class="line"><span class="cl">root@bbf4a330635d:~#
</span></span></code></pre></div><p>进入容器后，开始安装nginx：</p>
<h3 id="apt-get安装">apt-get安装</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ apt-get update  // 更新软件源
</span></span><span class="line"><span class="cl">$ apt-get install nginx  // 更新软件源
</span></span><span class="line"><span class="cl">$ nginx   // 启动
</span></span><span class="line"><span class="cl">$ ps -ef   // 显示所有进程信息
</span></span><span class="line"><span class="cl">UID        PID  PPID  C STIME TTY          TIME CMD
</span></span><span class="line"><span class="cl">root         <span class="m">1</span>     <span class="m">0</span>  <span class="m">0</span> 08:26 pts/0    00:00:00 /bin/bash
</span></span><span class="line"><span class="cl">root      <span class="m">3757</span>     <span class="m">1</span>  <span class="m">0</span> 08:58 ?        00:00:00 nginx: master process nginx
</span></span><span class="line"><span class="cl">www-data  <span class="m">3758</span>  <span class="m">3757</span>  <span class="m">0</span> 08:58 ?        00:00:00 nginx: worker process
</span></span><span class="line"><span class="cl">root      <span class="m">3759</span>     <span class="m">1</span>  <span class="m">0</span> 08:58 pts/0    00:00:00 ps -ef
</span></span></code></pre></div><h3 id="源码编译安装">源码编译安装</h3>
<p>上一种的安装方式，在生产环境下可能会显得自定义性不强，或者安装包比较老。更多的时候我们需要下载源码编译安装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ wget http://nginx.org/download/nginx-1.14.0.tar.gz  // 目前最新稳定版
</span></span><span class="line"><span class="cl">$ tar -zxvf nginx-1.14.0.tar.gz //解压
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> nginx-1.14.0.tar.gz  
</span></span><span class="line"><span class="cl">$ apt-get install libpcre3 libpcre3-dev zlib1g-dev build-essential libtool  // 编译前安装依赖包
</span></span><span class="line"><span class="cl">$ ./configure  // 可以在后面定制安装
</span></span><span class="line"><span class="cl">$ make
</span></span><span class="line"><span class="cl">$ sudo make install
</span></span></code></pre></div><p>这样我们就安装成功了，默认情况<code>nginx</code>会安装在<code>/usr/local/nginx</code>目录中启动：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ /usr/local/nginx/sbin/nginx   // 启动
</span></span><span class="line"><span class="cl">$ /usr/local/nginx/sbin/nginx -s reload  // 重启
</span></span><span class="line"><span class="cl">$ /usr/local/nginx/sbin/nginx -s stop   // 关闭进程
</span></span><span class="line"><span class="cl">$ /usr/local/nginx/sbin/nginx -s quit  // 平滑关闭nginx
</span></span></code></pre></div><h2 id="反向代理">反向代理</h2>
<p>假如用户 A 要得到网站 C 的内容，而用户 A 因为网络原因又不能直接访问到，而服务器 B 可以访问到网站 C，那服务器可以得到网站 C 的内容再存起来发给用户 A，这整个过程用户 A 是直接和服务器 B 交互的，用户 A 不知道网站 C 的存在。那web服务器 B 就是一台反向代理服务器，C 是上游服务器。</p>
<p><code>nginx</code>的反向代理是依赖于<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a>这个自带<code>module</code>来实现的。我们以本站图片请求反向代理为例：</p>
<p>由于本站用的是<code>https</code>协议，在浏览器的地址栏可以看到绿色的锁。而如果图片不是存储在本地服务器，而是放在七牛，又拍云这样的地方，图片的外链是<code>http</code>协议的(当然七牛本身是可以开启<code>https</code>协议的，只是并非免费)。那么在浏览器的地址栏，虽然显示的是<code>https</code>协议，却没有绿色安全锁。</p>
<p>所以我们要把<code>https</code>协议请求的图片地址反向代理到<code>http</code>协议的真实图片上。事实上<code>https</code>协议请求的图片是不存在，而如果使用反向代理，它就有一个指向http协议图片的实际地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="k">server</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kn">server_name</span>    <span class="s">www.yukunweb.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kn">listen</span>         <span class="mi">443</span><span class="p">;</span>  <span class="c1"># 443端口用于HTTPS服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kn">location</span> <span class="s">/qiniu/post36_0.jpg</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_pass</span> <span class="s">http://opxib6gmc.bkt.clouddn.com/post36_0.jpg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">opxib6gmc.bkt.clouddn.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kn">location</span> <span class="s">/example.jpg</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_pass</span> <span class="s">http://example.com/example.jpg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样我们就可以通过访问<code>https://www.yukunweb.com/qiniu/post36_0.jpg</code>来请求到<code>http://opxib6gmc.bkt.clouddn.com/post36_0.jpg</code>的图片。</p>
<p><code>Nginx</code>的<code>sever</code>块主要是服务器的配置(域名，IP，端口等)，在一个<code>Nginx</code>的配置文件里面，我们可以有多个<code>sever</code>块配置。而<code>location</code>块则是在<code>sever</code>块里面，对不同请求路径进行的配置。因为一个站点中的<code>URI</code>通常会非常多，所以在<code>location</code>块设置这部分，同样可以写多个<code>location</code>的配置。当然我们不能为每一个<code>URI</code>都进行配置，我们来看一些动态匹配语法：</p>
<h3 id="location语法说明">location语法说明</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">syntax: location [=|~|~*|^~|@] /uri/ { ... }
</span></span><span class="line"><span class="cl">default: no
</span></span><span class="line"><span class="cl">context: server
</span></span></code></pre></div><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>表示精确匹配，不支持正则</td>
</tr>
<tr>
<td>^~</td>
<td>表示uri以某个常规字符串开头，不支持正则，理解为匹配uri路径即可</td>
</tr>
<tr>
<td>~和~*</td>
<td>表示区分大小写的和不区分大小写的正则匹配</td>
</tr>
<tr>
<td>!~和!~*</td>
<td>表示区分大小写不匹配和不区分大小写不匹配的正则匹配</td>
</tr>
<tr>
<td>/</td>
<td>通用匹配，任何请求都会匹配</td>
</tr>
</tbody>
</table>
<p>匹配优先级 ：<code>=</code> &gt; <code>^~</code> &gt; <code>~/~*/!~/!~*</code> &gt; <code>/</code>。优先级的意思是当以<code>~/~*/!~/!~*</code>和<code>/</code>匹配到符合结果路径后，会继续往下判断其他配置项的匹配，如果<code>^~</code>语法也匹配到符合的则使用<code>^~</code>匹配到的结果，而<code>^~</code>匹配到结果后就不会再往下判断其他配置项是否满足。</p>
<p><code>proxy_set_header</code>配置重写请求上游服务器头的内容，我们这里设置了请求头<code>Host</code>参数。</p>
<p>现在我们重新写上面的配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="k">server</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kn">server_name</span>    <span class="s">www.yukunweb.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kn">listen</span>         <span class="mi">443</span><span class="p">;</span>  <span class="c1"># 443端口用于HTTPS服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kn">location</span> <span class="s">^~</span> <span class="s">/qiniu/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_pass</span> <span class="s">http://opxib6gmc.bkt.clouddn.com/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">opxib6gmc.bkt.clouddn.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1"># 反向代理avatar.com的头像
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kn">location</span> <span class="s">^~</span> <span class="s">/avatar/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_pass</span> <span class="s">http://www.avatar.com/</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">www.avatar.com</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="静态文件缓存">静态文件缓存</h2>
<p>以本战<code>flask</code>程序为例，由于静态文件(比如css/js/图片等)，都是不经常更新的。可以使用<code>nginx</code>的<code>proxy_cache</code>将这些静态文件的响应结果缓存到本地一个目录。这样不仅可以减少服务器处理请求的压力，还有一定程度上提高程序响应速度。</p>
<p>下面是本站缓存配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="c1"># nginx.conf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">http{</span>
</span></span><span class="line"><span class="cl">    <span class="s">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="s">proxy_temp_path</span> <span class="s">/tmp/temp_dir</span><span class="p">;</span>  <span class="c1"># 从后端服务器接收的临时文件的存放路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># 设置缓存的路径和其他参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># levels 设置缓存文件目录层次；levels=1:2 表示两级目录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># keys_zone 设置缓存名字和共享内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># inactive 在指定时间内没人访问则被删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># max_size 最大缓存空间，如果缓存空间满，默认覆盖掉缓存时间最长的资源。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">proxy_cache_path</span> <span class="s">/tmp/cache</span> <span class="s">levels=1:2</span> <span class="s">keys_zone=tmp_cache:100m</span> <span class="s">inactive=1d</span> <span class="s">max_size=10g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="s">server</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kn">...</span>
</span></span><span class="line"><span class="cl">    <span class="err">}</span>
</span></span><span class="line"><span class="cl"><span class="err">}</span>
</span></span></code></pre></div><p>本站程序的<code>sever</code>块配置在<code>sites-available/default</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="line"><span class="cl"><span class="c1"># default
</span></span></span><span class="line"><span class="cl"><span class="c1"># 缓存 flask 的static文件夹下所有静态文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">server</span> <span class="s">^~</span> <span class="s">/static/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kn">root</span> <span class="s">/root/project/YuBlog/app/</span><span class="p">;</span> <span class="c1"># 指定文件路径，root不需要在后面加static,alias需要
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kn">proxy_cache</span> <span class="s">tmp_cache</span><span class="p">;</span>  <span class="c1"># 使用名为tmp_cache的对应与http中的缓存配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kn">expires</span> <span class="s">30d</span><span class="p">;</span>  <span class="c1"># 缓存时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>配置完我们需要重启<code>nginx</code>：<code>/usr/local/sbin/nginx -s reload</code></p>
<p>如果没有报错就说明成功了，如果有错误可以使用<code>/usr/local/sbin/nginx -t</code> 查看错误原因。这是打开浏览器可以查看静态文件是否进行缓存了，看响应头中<code>Expires</code>的时间。如果响应头中没有<code>expires</code>信息，而 nginx 也没有出错，那么可能是 nginx 的缓存没有写入权限。这是要在<code>nginx.conf</code>顶部配置有写入权限的用户。</p>
<p><img src="/image/post36/post36_0.jpg" alt="post36_0.jpg"></p>
<p>当然，上面反向代理的图片也是可以缓存的，只需要在他们的<code>location</code>配置中加入对应配置就可以了。</p>
<h2 id="最后">最后</h2>
<p>参考文章：<a href="https://blog.csdn.net/dengjiexian123/article/details/53386586">nginx proxy_cache 缓存配置</a>{:target=&quot;_blank&quot;}</p>
<p>推荐教程：<a href="http://tengine.taobao.org/book/index.html">从入门到放弃</a>{:target=&quot;_blank&quot;}</p>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://yokonsan.com/tags/nginx/">nginx</a>
                                    
                                    <a href="https://yokonsan.com/tags/ubuntu/">ubuntu</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://github.com/varkai/hugo-theme-zozo">Designed by zozo,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>博观约取，厚积薄发</span>
    </div>
</footer>
    <script src="https://yokonsan.com/js/jquery-3.5.1.min.js"></script>
<link href="https://yokonsan.com/css/fancybox.min.css" rel="stylesheet">
<script src="https://yokonsan.com/js/fancybox.min.js"></script>
<script src="https://yokonsan.com/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



</body>

</html>